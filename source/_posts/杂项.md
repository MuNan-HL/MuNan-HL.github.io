---
title: 杂项
date: 2024-8-5
---
这里会记录非系统性的内容, 临时记录, 用于后期查漏补缺.

``` md
> 1. 你怎么理解正向代理和反向代理?
- 1. 正向代理, 你知道你要访问的目标服务器的真实地址, 只是借由正向代理服务器去访问目标服务器.

- 2. 反向代理, 你不知道你要访问的目标服务器的真实地址, 只能通过访问反向代理服务器, 让反向代理服务器访问目标服务器.

- 补充知识1, 代理服务器就是一个中介, 如果你事先知道目标服务器, 则此时的代理就是正向代理, 反之则为反向代理.
```

``` md
> 2. 后端常说的 B 端项目和 C 端项目是什么?
- 1. B 端项目, 面向商家的项目, B business 商家.

- 2. C 端项目, 面向消费者的项目, C customer 消费者.
```
- [参考资料1 B 端和 C 端](https://juejin.cn/post/7032286415819898911)

- [参考资料2 B 端和 C 端](https://www.lmdouble.com/1505342288.html)

``` md
> 3. 你怎么理解架构?
- 1. 以 Pig4Cloud 微服务架构图为例

- 补充知识1, 要了解架构, 首先需要知道是什么类型的架构. 例如此处的架构, 是指软件架构.

- 补充知识2, 微服务架构, 是指一种将单个应用解耦分为多个独立的组件进行开发和部署的软件架构.
```
- [参考资料 Pig4Cloud](https://paper.pig4cloud.com/#%E5%85%B3%E4%BA%8E-pig-%E5%95%86%E4%B8%9A%E7%89%88)

- [参考资料 微服务架构](https://www.ibm.com/cn-zh/topics/microservices)

``` md
> 4. 基于 Pig4Cloud 的学习资料
```
- [参考资料 学习资料](https://www.yuque.com/pig4cloud/pig/fyecgc)

``` md
> 5. 系统架构设计参考
```
- [参考资料 系统架构](https://juejin.cn/post/7081481794909896712)

``` md
> 6. 比如我本地做好后台接口了
本地通过http://localhost:8080/MyProject/hello能访问。
但是怎么发布出去呢？怎么让别人也能访问？
我不是要发布域名之类的，就是让别的手机可以访问http://localhost:8080/MyProject/hello这个接口。
小弟我做app开发的，最近刚学后台技术。ssh整合学的好累，那个struts现在还有公司用么？感觉spring mvc注解好爽啊。

- 1. http://localhost:8080/MyProject/hello是你在自己电脑上访问的URL
别人访问就是把localhost改成你电脑的IP（用了路由器的话，要设置路由器映射地址），在电脑里配置8080端口可以访问。
```

``` md
> 7. localhost 是什么？
- 1. localhost 127.0.0.1， 是一个 IP 地址， 是为计算机的本地服务器保留的，所以你永远不会找到其他以 127 开头的 IP 地址。
```
- [参考资料 localhost 127.0.0.1](https://www.freecodecamp.org/chinese/news/what-is-localhost/)

``` md
> 8. Vue 启动项目后提供的那个 Network IP 地址是什么?
- 1. Vue 项目启动后所提供的 Local 本地和 Newwork 网络两个地址可以用来在本地或者同一局域网下访问你的项目.
```
- [参考资料](https://blog.csdn.net/m0_67372185/article/details/127706725)

``` md
> 9. Git 版本控制需求如何将远程仓库从 ssh 协议连接切换为 https 协议连接?
- 1. 相关命令
```
``` git
- 1. git remote remove origin // 删除远程仓库

- 2. git remote add origin <https 地址> // 利用 https 协议添加远程仓库
```

``` md
> 10. Git 版本控制系统怎么创建分支?
- 1. git branch <branch_name>

- 2. git switch <branch_name>
```

``` md
> 11. Git 版本控制系统, 怎么查看远程仓库的信息?
- 1. git remote -v
```

``` md
> 12. 解决element中el-select与el-input的输入框宽度不一致的问题
- 1. 默认情况就是 input 输入 和 select 选择表单项的长度不同, select 选择的表单项比 input 输入表单项宽度小, 所以设置样式即可
```
``` css
style="width: 100%"
```
- [参考资料 解决element中el-select与el-input的输入框宽度不一致的问题](https://blog.csdn.net/omroji/article/details/135717993)

``` md
> 13. 为什么实例化后的对象实例，访问原型对象是 undefined
- 1. 通过 new 实例化得到的一个对象实例, 当该对象访问其 prototype 原型对象时, 需要显示的设置其 __proto__ 原型属性. 如果你直接访问一个对象的原型对象，而该对象并没有显式地设置其原型，那么它的原型对象将是undefined

- 2. 代码示例:
```
``` js
// 创建一个构造函数
function Person(name) {
  this.name = name;
}

// 创建一个原型对象
const personPrototype = {
  sayHello: function() {
    console.log('Hello, my name is ' + this.name);
  }
};

// 创建一个Person实例
const person1 = new Person('Alice');

// 使用Object.setPrototypeOf()方法设置person1的原型为personPrototype
Object.setPrototypeOf(person1, personPrototype);

// 现在可以调用sayHello方法了
person1.sayHello(); // 输出： Hello, my name is Alice
```

``` md
> 14. git merge 合并中的快速合并和非快速合并你理解吗？
- 1. git merge 合并有两种合并方式, 一种是 fast-forward 快进合并, 一种是非快进合并, fast-forward 快进合并只有当当前分支是待合并分支的直接上游时会进行 fast-forward 快进合并, 否则就是非快速合并. fast-forward 快进合并只是单纯的 HEAD 指针移动, 而不会创建新的提交对象. 但是 not-fast-forward 非快进合并会创建新的提交对象, 并指向其父提交对象.

- 补充知识1, git merge 合并分支时会产生冲突的原因, 是因为你在进行 not-fast-forwar 非快进合并的时候, 对当前的分支和待合并分支的同一文件的同一地方都进行了不同的修改, 则会产生合并冲突, 需要手动解决冲突. `因此, 建议创建新分支的时候, 应该从最后一次提交对象处创建分支`.

- 补充知识2, git merge not-fast-forwar 非快进合并本质是进行`三方合并`, 首先会创建一个新的提交对象, 然后在当前分支, 待合并分支和新的提交对象之间进行`增量合并(即在比较差异后, 将其中增加的部分进行合并, 需要注意的是, 修改本质是进行删除然后在增加, 因此才产生的增量合并和减量合并两种合并算法)`. 不理解增量的含义, 你可以看看 VSCode 的 Git 插件中可视化的文件改动, + 和 - 部分, + 表示的是增加的地方, - 表示是删除的地方.
```
![增量合并](../_posts/增量合并.png)
``` md
- 2. 代码示例
```
``` git
git branch <feature-name> <hash> // 创建分支

git merge <feature-name> // 合并分支

git push <origin> <feature-name> // 推送分支
```
- [参考资料 git merge 合并](https://blog.csdn.net/qq_42780289/article/details/97945300)

``` md
> 15. line wrap 换行的含义
- 1. line wrap 表示的是换行.
```

``` md
> 16. href 的中文含义
- 1. hyperlink reference 超链接引用. 用于指定一个 URL 统一资源定位器.
```

``` md
> 17. 计算机的硬件主要包括那几个部分?
- 1. 主要由 10 个硬件组成. CPU /sen/p/u/中央处理单元, GPU /ɡræ/p/u/图像处理单元, RAM 随机存取存储器, SSD /ˈsɒ/s/d/固态硬盘, HDD /hɑːr/di/d/ 机械硬盘, Network card 网卡, Sound card 声卡, Motherboard 主板, keyboard 键盘, Monitor 显示器, Mouse 鼠标. 
```

``` md
> 18. iframe /ɪn/freɪm/内联框架的中文翻译
- 1. HTML 超文本标记语言中的 iframe 内联框架.
```

``` md
> 19. git merge 合并的 not-fast-forward 非快进合并逻辑
- 1. not-fast-forward 非快进合并会进行三方合并(当前分支最新提交对象, 待合并分支的最新提交对象, 以及最近的公共祖先, 然后比较差异, 再进行增量合并, 有冲突则解决冲突)
```
- ![图解1 not-fast-forward 非快进合并](../image/图解1not-fast-forward非快进合并.png)

- ![图解2 not-fast-forward 非快进合并](../image/图解2not-fast-forward非快进合并.png)

- [参考资料 not-fast-forward 非快进合并](https://yanglei253.github.io/2020/12/21/git/gitintroduce1-mergeStrategy/)

``` md
> 20. git log 日志 和 git reflog 引用日志的区别?
- 1. git log 日志, 是用来查看当前分支的提交记录. 而 git reflog 引用日志, 是用来查看所有分支的提交记录. 且它们展示的数据格式也不相同. 
```

``` md
> 21. Git 分布式版本控制系统分支的最佳实践
- 1. 首先, git branch 创建分支, 首先要去拉取最新的生产分支的代码, 然后在最新提交记录处创建新的 feature 特性分支.

- 2. 然后, git merge 合并分支, 是由生产分支去合并 feature 特性分支或者 fix 修复分支. `切记不要合并 test 测试分支`

- 补充知识1, 遵守最佳实践的目的, 是为了防止合并冲突, 以及避免污染生产分支.
```

``` md
> 22. 如何查看 Git 分布式版本控制系统的分支图?
- 1. 通过 git log --graph 日志的图形化来查看当前分支的提交日志.

- 补充知识1, 你还可以通过 git reflog --all 引用日志, 查看所有分支的提交记录.
```

``` md
> 23. 如何进行纯函数编程?
- 1. 通过柯里化函数, 组合函数等实现纯函数编程, 但是重点在于纯函数的思想, 即`一个输入对应一个输出, 且没有副作用`.
```
- [参考资料 纯函数编程](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)

``` md
> 24. 在 element 组件库中的 select 选择框中, 显示的是 label 标签, 但是值是 value 值, 因此赋值时只需要给 value 即可.
```

``` md
> 25. 开发过程中, 有人问你, 你的项目是在那个服务, 你该怎么回答?
- 1. 首先, 你要有一个基本概念, 就是软件架构分为单体架构和面向服务架构. 因此一个服务就是指一个独立的功能单元, 一个软件是由多个服务组成, 每个服务又是由多个模块组成的. 因此在需求分析阶段, 你就需要知道当前项目是那个的服务的哪个模块.

- 2. 回答, 需要根据你的实际情况回答, 我个人而言, 开发过的服务有 TPC 流程中心, UD 统一用户, VFORM 原型设计, ECL 问题管理. 而我开发过的模块有年休假考勤, PRD 流程审批, 法规及技术标准...等.

- 补充知识1, 微服务架构, 一种服务完全分离的软件架构. `优点就是更小更易维护`. 

- 补充知识2, 软件架构, 一种软件的开发结构, 分为单体架构(紧耦合) => 面向服务架构(松耦合) => 微服务架构(完全分离).
```
- [参考资料 软件架构](https://www.ruanyifeng.com/blog/2022/04/microservice.html)

``` md
> 26. 什么时候使用 Map 字典?
- 1. 三种情况吧, 1. 当 key 键是复杂数据类型时, 2. 或者需要频繁的增删改查的时候, 3. 或者是需要计算 key 键的数量的时候, 建议使用 Map 字典.

- 补充知识1, 可以通过 entries 条目将 Object 对象转换为 Map 字典, 通过 fromEntries 可以将 Map 字典转换为 Object 对象.
```
``` js
const obj = {
  a: '我是obj.a',
  b: '我是obj.b',
  c: '我是obj.c',
}
console.log(obj)
const map = new Map(Object.entries(obj))
console.log(map)
console.log(map.get('a'), '我是map 属性名')
console.log(map.get('b'), '我是map 属性名')

const arr = [1, 2, 3];
obj = { a: '1', b: 2 };
const map = new Map()
map.set(arr, '我是map的第1个值，我是数组')
map.set(obj, '我是map的第2个值，我是对象')
const newObj = Object.fromEntries(map.entries())
console.log(newObj, '我是新对象')
console.log('新对象类型', typeof newObj)
```
- [参考资料1 Map 字典](https://juejin.cn/post/6981995678327111717#heading-2)

- [参考资料2 Map 字典](https://blog.csdn.net/weixin_46112649/article/details/126038160)

``` md
> 27. syntaxError, Unexpected reserved word ‘await‘ 的原因是什么?
- 1. 我会产生这种异常的原因是因为, 没有给匿名函数添加 async 异步, 而直接使用了 await 等待. 
```
``` js
async handleDelete() {
  let folderFilesIds = [1, 2]
  this.$confirm('此操作将永久删除文件, 是否继续?', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).then(() => {
    await this.confirmHandleFiles(folderFilesIds)
  }).catch(() => {
    this.$message({
      type: 'info',
      message: '已取消删除'
    });
  });
},

// 修改
handleDelete() {
  let folderFilesIds = [1, 2]
  this.$confirm('此操作将永久删除文件, 是否继续?', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).then(async () => {
    await this.confirmHandleFiles(folderFilesIds)
  }).catch(() => {
    this.$message({
      type: 'info',
      message: '已取消删除'
    });
  });
```
- [参考资料 syntaxError, Unexpected reserved word ‘await‘ 的原因是什么?](https://blog.csdn.net/m0_37714008/article/details/119349924)

``` md
> 28. 声明式编程和命令式编程的区别?
- 1. 声明式编程在于目的, 命令式编程在于步骤.
```

``` md
> 29. 你怎么理解网络请求的 5 方式方式
- 1. GET 获取请求, 用于获取数据, POST 发送请求, 用于发送数据, PUT 更新请求, 用于更新数据, PATCH 更新请求, 用于局部更新数据. DELETE 删除请求, 用于删除数据.

- 补充知识1, 这只是发送网络请求的最佳实践, 当然, 你不想遵守也完全可以, 只是会被别人不待见.
```